Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
rm(list = ls())
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
geomorph:::gm.prcomp(Y.gpa$coords)
A <- Y.gpa$coords
phy <- NULL
align.to.phy <- FALSE
GLS <- FALSE
transform <- FALSE
if (is.array(A)) {
dims <- dim(A)
if (length(dims) == 3) {
if (any(is.na(A)))
stop("Data matrix contains missing values. Estimate these first (see 'estimate.missing').\n",
call. = FALSE)
p <- dims[1]
k <- dims[2]
n <- dims[3]
}
else if (length(dims) == 2) {
n <- dims[1]
k <- NULL
p <- dims[2]
}
}else {
A <- try(as.matrix(A), silent = TRUE)
if (inherits(A, "try-error"))
stop("Data not of a form coercible to matrix or array.\n",
call. = FALSE)
dims <- dim(A)
n <- dims[1]
k <- NULL
p <- dims[2]
}
ord.args <- list(...)
ord.args <- list() ##########
if (!is.null(k)) {
Y <- two.d.array(A)
ord.args$Y <- Y
} else ord.args$Y <- Y <- A
if (is.null(ord.args$tol)) ord.args$tol <- sqrt(.Machine$double.eps)
if (!is.null(phy)) {
if (!inherits(phy, "phylo"))
stop("Tree must be of class 'phylo.'\n", call. = FALSE)
N <- length(phy$tip.label)
Nnode <- phy$Nnode
if (N != n)
stop("Number of taxa in data matrix and tree are not equal.\n",
call. = FALSE)
if (is.null(rownames(Y))) {
warning("Shape dataset does not include species names. Assuming the order of data matches phy$tip.label")
rownames(Y) <- phy$tip.label
}
ancY <- anc.BM(phy, Y)
if (is.null(rownames(Y))) {
rownames(Y) <- phy$tip.label
cat("Warning: Data are not labeled so it is assumed they are in the same order as tree names.\n")
}
phy.mat <- phylo.mat(Y, phy)
C <- phy.mat$C
if (align.to.phy)
ord.args$A <- C
if (GLS)
ord.args$Cov <- C
}
ord.args$transform. = transform
out <- do.call(ordinate, ord.args)
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
colnames(r$x) <- colnames(s$v)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
library(geomorph)data(plethspecies)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
ls()
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
Y.gpa <- gpagen(plethspecies$land)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Stable")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
shiny::runApp('published')
runApp('in_development')
devtools::install_github("geomorphR/geomorph", ref = "Develop")
library(geomorph)
data(plethspecies)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Stable", force = T)
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("RRPP/geomorph", ref = "Develop")
devtools::install_github("mlcollyer/RRPP", ref = "develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
View(updateOrderInput)
View(updateOrderInput)
View(tryObserveEvent)
View(tryObserveEvent)
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('published')
devtools::install_github("mlcollyer/RRPP", ref = "develop")
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
warnings()
runApp('in_development')
runApp('in_development')
rsconnect::terminateApp("shiny_test")
rsconnect::terminateApp("Shiny-Test")
rsconnect::terminateApp("Shiny_test-tutorial")
rsconnect::terminateApp("Shiny_test-geomorph")
?require
remove.packages("ape")
remove.packages("prettycode")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert", "shinyMatrix", "shinyjqui", "shinymeta", "prettycode", "ape", "stringr", "stringi", "shinyforms", "RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
?install.packages
install.packages(c("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy"))
library(shiny); library(shinyjs); library(shinyWidgets); library(shinydashboard); library(shinythemes)
library(shinyalert); library(shinyMatrix); library(shinyjqui); library(shinymeta); library(prettycode)
library(geomorph); library(ape); library(stringr); library(stringi); library(shinyforms)
library(RColorBrewer); library(reactlog); library(StereoMorph); library(shinybusy)
runUrl("https://github.com/geomorphR/gmShiny/archive/master.tar.gzâ€)
"0"
runUrl("https://github.com/geomorphR/gmShiny/archive/master.tar.gz")
shiny::runUrl("https://github.com/geomorphR/gmShiny/archive/master.tar.gz")
shiny::runUrl("https://github.com/geomorphR/gmShiny/archive/master.tar.gz")
shiny::runApp('in_development')
getwd()
shiny::runApp('in_development')
?install_github
devtools::install_github("shinyMatrix")
?shinyMatrix
library(shinyMatrix)
?shinyMatrix
?shiny-matrix
?shinyMatrix
??shinyMatrix
?matrixInput
uninstall.packages("shinyMatrix")
library(installr)
remove.packages("shinyMatrix")
?matrixInput
devtools::install_github("INWTlab/shiny-matrix")
library(shinyMatrix)
?matrixInput
?matrixInput
?matrixInput
library(shinyMatrix)
?shinyMatrix
?matrixInput
library(shinyMatrix)
?matrixInput
remotes::install_github("INWTlab/shiny-matrix")
remotes::install_github("INWTlab/shiny-matrix", force = T)
library(shinyMatrix)
?matrixInput
shiny::runApp('in_development')
packageVersion("shiny")
packageVersion("shinyjs")
install_version("shinyjs",version = "2.0.0")
# Version downloads
library(devtools)
shiny::runApp('in_development')
install_version("shinyjs",version = "2.0.0")
packageVersion("shinyalert")
install_version("shinyalert", version = "2.0.0")
runApp('in_development')
packageVersion("shinyalert")
packageVersion("shinymeta")
install_version("shinymeta", version = "0.2.0.1")
packageVersion("prettycode")
packageVersion("ape")
install_version("ape", version = "5.5")
# Version downloads
library(devtools)
install_version("ape", version = "5.5")
packageVersion("ape")
packageVersion("stringr")
packageVersion("stringi")
install_version("stringi", version = "1.6.2")
packageVersion("shinyforms")
packageVersion("RColorBrewer")
# Version downloads
library(devtools)
packageVersion("reactlog")
packageVersion("StereoMorph")
shiny::runApp('in_development')
packageVersion("StereoMorph")
packageVersion("shinybusy")
packageVersion("shinyforms")
shiny::runApp('in_development')
packageVersion("shiny")
packageVersion("shinyjs")
packageVersion("shinyalert")
packageVersion("shinyWidgets")
packageVersion("shinydashboard")
packageVersion("shinythemes")
packageVersion("shinyMatrix")
packageVersion("shinyjqui")
packageVersion("shinymeta")
install_version("shinymeta", version = "0.2.0.1")
# Version downloads
library(devtools)
install_version("shinymeta", version = "0.2.0.1")
install_version("shinymeta", version = "0.2.0.1")
packageVersion("shinymeta")
install_version("shinymeta", version = "0.2.0.1")
shiny::runApp('in_development')
packageVersion("geomorph")
install_version("geomorph", version = "4.0.1")
runApp('in_development')
#
packageVersion("shinyforms") # DOESN'T EXIST FOR 3.6.3, which is the newest version of R for linux?
uninstall("shinyforms")
libraryshinyforms
library(shinyforms)
remove.packages("shinyforms")
library(shinyforms)
detach(shinyforms)
detach("shinyforms")
library(shinyforms)
shiny::runApp('in_development')
packageVersion("RRPP")
View(pruning_script_function)
View(pruning_script_function)
View(tryObserve)
runApp('in_development')
packageVersion("geomorph")
runApp('in_development')
runApp('in_development')
?downloadHandler
View(plotOutliers.ekb2)
